인덱스 (Index)
: 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 
-> 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아보는 것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.


- 인덱스의 장점과 단점
  * 장점
   : 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
   : 전반적인 시스템의 부하를 줄일 수 있다.
  * 단점
   : 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
   : 인덱스를 관리하기 위해 추가 작업이 필요하다.
   : 인덱스를 잘못 사용할 경우 오히려 성능 저하되는 역효과가 발생할 수 있다.
     -> create, delete, update가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생한다.

- 인데스를 사용하면 좋은 경우
  * 규모가 작지 않은 테이블
  * insert, update, delete가 자주 발생하지 않는 컬럼
  * Join이나 where 또는 Order By에 자주 사용되는 컬럼
  * 데이터의 중복도가 낮은 컬럼


- 인덱스의 자료 구소
  * 해시 테이블(Hash Table)
   : 해시 테이블은 (key, value)로 데이터를 저장하는 자료구조 중 하나로 빠른데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.

   -> 부등호 연산(<, >)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

   * B+Tree
    : B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(value)를 저장했던 B+Tree와 다른 특성을 가지고 있다.
      - 리프노드(데이터노드)만 인덱스와 함께 데이터(value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(key)만을 갖는다.
      - 리프노드들은 LinkedList로 연결되어 있다.
      - 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

      -> 인덱스 컬럼은 부등로를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 BTree의 리드노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화하였다.  